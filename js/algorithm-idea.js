// just store some text for algorithmIdea
let quickSortText = "设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据 （通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。一趟快速排序的算法是：<br> 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br> 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br> 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br> 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）";
let bubbleSortText = "冒泡排序算法的运作如下：（ 从后往前)<br>1: 比较相邻的元素。 如果第一个比第二个大， 就交换他们两个。 <br>2: 对每一对相邻元素作同样的工作， 从开始第一对到结尾的最后一对。 在这一点， 最后的元素应该会是最大的数。 <br>3: 针对所有的元素重复以上的步骤， 除了最后一个。 <br>4: 持续每次对越来越少的元素重复上面的步骤， 直到没有任何一对数字需要比较";
let bubbleSortBetterText = "使用Flag的冒泡排序算法的运作如下：（ 从后往前)<br>1: 设置一个Flag为true,比较相邻的元素。 如果第一个比第二个大， 就交换他们两个。 <br>2: 当开始比较时设置Flag为false,对每一对相邻元素作同样的工作， 从开始第一对到结尾的最后一对。 如果发生顺序交换，说明数组还未有序，设置Flag为true,在这一点， 最后的元素应该会是最大的数。 <br>3: 每次循环的最后都会判断Flag的值，如果为false就结束循环比较，针对所有的元素重复以上的步骤， 除了最后一个。 <br>4: 持续每次对越来越少的元素重复上面的步骤， 直到没有任何一对数字需要比较";
let selectionSortText = "选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。";
let insertionSortText = "一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</br>1:从第一个元素开始，该元素可以认为已经被排序</br>2:取出下一个元素，在已经排序的元素序列中从后向前扫描</br>3:如果该元素（已排序）大于新元素，将该元素移到下一位置</br>4:重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</br>5:将新元素插入到该位置后</br>6:重复步骤2~5</br>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。";
let shellSortText = "希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</br>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</br>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</br>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）";
let mergeSortText = "归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</br>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。迭代法<br>1:申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</br>2:设定两个指针，最初位置分别为两个已经排序序列的起始位置</br>3:比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</br>4:重复步骤3直到某一指针到达序列尾</br>5:将另一序列剩下的所有元素直接复制到合并序列尾";
let heapSortText = "堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。</br>1）用大根堆排序的基本思想</br>① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区</br>② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key</br>③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。</br>……</br>直到无序区只有一个元素为止。</br>2）大根堆排序算法的基本操作：</br>①建堆，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。</br>②调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。</br>③堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlgn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn)";
let countingSortText = "计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)>O(n*log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）</br>计数排序对输入的数据有附加的限制条件：</br>1、输入的线性表的元素属于有限偏序集S；</br>2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。</br>在这两个条件下，计数排序的复杂性为O(n)。</br>计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。";
let radixSortText = "基数排序（radix sort）属于分配式排序（distribution sort），又称桶子法（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些桶中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</br>";
let bucketSortText = "桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</br>桶排序须知：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</br>为了使桶排序更加高效，我们需要做到这两点：</br>在额外空间充足的情况下，尽量增大桶的数量</br>使用的映射函数能够将输入的N个数据均匀的分配到K个桶中</br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</br>什么时候最快（Best Cases）：</br>当输入的数据可以均匀的分配到每一个桶中</br>什么时候最慢（Worst Cases）：</br>当输入的数据被分配到了同一个桶中";
let arrayDistinct1Text = "使用一个临时数组，通过使用JavaScript原生的indexOf方法，在临时数组中对数组中的每一项使用，如果临时数组中不存在则说明此项是唯一的，将其push进临时数组中，如果存在则说明之前已经添加过，即是重复的元素。最后，临时数组中的元素即是所有不重复的元素。"
let arrayDistinct2Text = "使用一个对象，如果对象中不存在某一项则将在对象中设置此项的键值为true，并将其push到新数组中，如果存在，即表示为重复的元素，不作任何操作，最后新数组中存的就是去重后的数组。"
let arrayDistinct3Text = "仍然使用原生的indexOf方法，在一个要去重的数组上使用indexOf方法（查找的当前i位置的值），如果返回的位置值和当前循环的遍历次数（i）一致，说明此处是当前元素第一次出现的位置，将该元素push到一个新数组中，不一致说明此处不是该元素第一次出现过的位置（因为是重复的所以indexOf返回的位置值会小于i），继续下一次循环。"
